# 事件冒泡、事件捕获与事件委托

## 事件冒泡

当一个dom触发指定事件时，会一直向上触发其容器的此事件，直到window对象为止。

html:

    <div id="parent">
      <div id="child"></div>
    </div>

js:

    window.addEventListener('click', function (e) {
      console.log('window')
    })

    document.addEventListener('click', function (e) {
      console.log('document')
    })

    document.documentElement.addEventListener('click', function (e) {
      console.log('documentElement')
    })

    document.body.addEventListener('click', function (e) {
      console.log('body')
    })

    document.getElementById('parent').addEventListener('click', function (e) {
      console.log('parent')
    })

    document.getElementById('child').addEventListener('click', function (e) {
      console.log('child')
    })

当点击child时，会看到浏览器输出：child -> parent -> body -> documentElement -> document -> window，这就是事件冒泡，从被点击的dom开始，一路向上传递。

## 事件捕获

与事件冒泡相反，当一个dom触发指定事件时，会先从window对象开始，一直向下触发其子元素的此事件，直到这个dom为止。

大部分浏览器事件机制默认为事件冒泡，如果想要更改为事件捕获，可将addEventListener方法的第三个参数设置为true（默认false即事件冒泡）。

    window.addEventListener('click', function (e) {
      console.log('window')
    }, true)

    document.addEventListener('click', function (e) {
      console.log('document')
    }, true)

    document.documentElement.addEventListener('click', function (e) {
      console.log('documentElement')
    }, true)

    document.body.addEventListener('click', function (e) {
      console.log('body')
    }, true)

    document.getElementById('parent').addEventListener('click', function (e) {
      console.log('parent')
    }, true)

    document.getElementById('child').addEventListener('click', function (e) {
      console.log('child')
    }, true)

当点击child时，会看到浏览器输出：window -> document -> documentElement -> body -> parent -> child，这就是事件捕获，从window开始，一路向下传递。

## 事件捕获与事件冒泡同时存在

上面展示的例子说明了事件捕获与事件冒泡好像只能存在其一，但其实它们是同时存在的，只是程序上不能体现出来。一个事件的触发会先进行捕获阶段，再进行冒泡阶段，从window对象开始，到window对象结束，如下图：

![事件流程图](https://images2015.cnblogs.com/blog/1005354/201612/1005354-20161222125521823-1914047378.png)

## 阻止事件冒泡与事件捕获

在支持addEventListener()方法的浏览器中，均可以使用event对象的stopPropagation()方法阻止事件冒泡与事件捕获。

    window.addEventListener('click', function (e) {
      console.log('window')
    })

    document.addEventListener('click', function (e) {
      console.log('document')
    })

    document.documentElement.addEventListener('click', function (e) {
      console.log('documentElement')
    })

    document.body.addEventListener('click', function (e) {
      console.log('body')
    })

    document.getElementById('parent').addEventListener('click', function (e) {
      console.log('parent')
      e.stopPropagation()
    })

    document.getElementById('child').addEventListener('click', function (e) {
      console.log('child')
    })

当点击child时，只会输出：child -> parent，后面的事件均被阻止。

    window.addEventListener('click', function (e) {
      console.log('window')
    }, true)

    document.addEventListener('click', function (e) {
      console.log('document')
    }, true)

    document.documentElement.addEventListener('click', function (e) {
      console.log('documentElement')
    }, true)

    document.body.addEventListener('click', function (e) {
      console.log('body')
      e.stopPropagation()
    }, true)

    document.getElementById('parent').addEventListener('click', function (e) {
      console.log('parent')
    }, true)

    document.getElementById('child').addEventListener('click', function (e) {
      console.log('child')
    }, true)

同理，当点击child时，只会输出：window -> document -> documentElement -> body，后面的事件均被阻止。

所以，请慎用事件捕获